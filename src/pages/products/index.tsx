import React from 'react';
import Head from 'next/head';
import styled from '@emotion/styled';
import { useInView } from 'react-intersection-observer';
import { ReadonlyURLSearchParams } from 'next/navigation';

import type { UserFilterList, ProductFilter } from '@/types/product';
import { useDisclosure, useLink, useSearchParamsState } from '@/hooks';
import { Flex, Header, Modal, SearchBar, ProductListItem } from '@/components';
import { useInfiniteProductScroll } from '@/api/query';
import { isPriceRangeKey, isSkinType } from '@/utils';
import { useUserSkinType } from '@/api/query/userQuery';

const DEFAULT_SIZE = 20;

const initialFilters = (searchParams: ReadonlyURLSearchParams): ProductFilter => ({
  search: searchParams.get('search') ?? '',
  size: DEFAULT_SIZE,
  skinTypes: searchParams.get('skinTypes')?.split(',').filter(isSkinType) ?? [],
  priceRanges: searchParams.get('priceRanges')?.split(',').filter(isPriceRangeKey) ?? [],
  categories: searchParams.get('categories')?.split(',') ?? [],
});

export default function ProductList({ filters: filterList }: { filters: UserFilterList }) {
  const { data: userSkinTypeData } = useUserSkinType();
  const link = useLink();
  const { ref, inView } = useInView();
  const { isOpen, onClose, onOpen } = useDisclosure();
  const { searchParams, setSearchParams } = useSearchParamsState({ type: 'products' });
  const [filters, setFilters] = React.useState<ProductFilter>(initialFilters(searchParams));
  const { data, fetchNextPage, hasNextPage } = useInfiniteProductScroll(filters);

  const handleFilterModalClose = React.useCallback(
    (filter: ProductFilter) => {
      setFilters((prev) => ({ ...prev, ...filter }));
      // 새로고침 시 page와 size는 기본값으로 설정되기 위해 param으로 추가하지 않는다.
      setSearchParams({
        skinTypes: filter.skinTypes?.map((v) => v).join(',') ?? [],
        categories: filter.categories?.map((v) => v).join(',') ?? [],
        priceRanges: filter.priceRanges?.map((v) => v).join(',') ?? [],
      });
      onClose();
    },
    [onClose, setSearchParams],
  );

  const handleClickSearch = React.useCallback(() => {
    setSearchParams({ search: filters.search });
  }, [filters.search, setSearchParams]);

  React.useEffect(() => {
    const initFilters = initialFilters(searchParams);
    setFilters(initFilters);
  }, [searchParams]);

  React.useEffect(() => {
    if (inView && hasNextPage) {
      fetchNextPage();
    }
  }, [fetchNextPage, inView, hasNextPage]);

  React.useEffect(() => {
    if (userSkinTypeData?.skinType && isSkinType(userSkinTypeData.skinType)) {
      const { skinType } = userSkinTypeData;
      setFilters((prev) => ({ ...prev, skinTypes: [skinType] }));
    }
  }, [userSkinTypeData]);

  return (
    <>
      <Head>
        <title>EGGY: Cosmetics</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Header />
      <main style={{ paddingInline: 34, paddingBlock: 80 }}>
        <SearchBar
          value={filters.search}
          filters={{
            categories: filters.categories,
            skinTypes: filters.skinTypes,
            priceRanges: filters.priceRanges,
          }}
          onChange={(e) => setFilters((prev) => ({ ...prev, search: e.target.value }))}
          onClickFilter={onOpen}
          onSearch={handleClickSearch}
        />
        <FlexWithLine flexDirection="column" gap={32} style={{ marginTop: 28 }}>
          <Flex flexDirection="column" gap={16} style={{ width: '100%' }}>
            {data?.pages.map((page, idx) => (
              <React.Fragment key={idx}>
                {page.data.map((product) => (
                  <ProductListItem
                    key={product.id}
                    product={product}
                    onClick={() => link.to('productItem', `${product.id}`)}
                  />
                ))}
              </React.Fragment>
            ))}
          </Flex>
          <div style={{ visibility: 'hidden' }} ref={ref} />
        </FlexWithLine>
      </main>
      <Modal
        type="filter"
        isOpen={isOpen}
        onClose={onClose}
        onSaveClose={handleFilterModalClose}
        data={{ filters, list: filterList }}
      />
    </>
  );
}

const FlexWithLine = styled(Flex)`
  & > div:not(:first-of-type) {
    padding-top: 16px;
    border-top: ${({ theme }) => `1px solid ${theme.colors.gray200}`};
  }
`;
